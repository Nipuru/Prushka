import os

from .st_parser import parse_st_file, find_all_st_files
from .config import Config

type_mapping = {
    "int32": "Int",
    "int64": "Long",
    "float32": "Float",
    "float64": "Double",
    "bool": "Boolean",
    "string": "String",
}

sheet_loader_template = """
// This file is auto-generated. DO NOT EDIT.
// Generated by tool
package server.common.sheet

import com.google.gson.FieldNamingPolicy
import com.google.gson.GsonBuilder
import com.google.gson.reflect.TypeToken

object Sheet {
    private var isLoad = false
    private val gson = GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create()

    fun load(sheets: Map<String, String>) {
<sheets>
        isLoad = true
    }

    fun check() {
        if (!isLoad) throw IllegalStateException("Sheet not loaded")
    }

    private inline fun <reified T> load(holder: SheetHolder<T>, json: String?) {
        holder.clear()
        if (json == null) return
        val type = object : TypeToken<List<T>>() {}.type
        val values = gson.fromJson<List<T>>(json, type)
        for (value in values) {
            holder.put(value)
        }
    }
}

interface SheetHolder<T> {
    fun put(value: T)
    fun clear()
}
"""

sheet_template = """
// This file is auto-generated. DO NOT EDIT.
// Generated by tool
package server.common.sheet

data class <name>(
<fields>
)

<extentions>

internal object <name>Holder : SheetHolder<<name>> {
<maps>
    override fun put(value: <name>) {
<mappings>
    }

    override fun clear() {
<clearings>
    }
}
"""

def generate_code():
    sheets = []
    st_files = find_all_st_files(Config.excel_path)

    for st_file_path in st_files:
        print('正在生成 %s' % (st_file_path))

        try:
            st = parse_st_file(st_file_path)
        except Exception as e:
            print('解析st文件失败: %s' % str(e))
            continue

        if not st.table_name:
            print('st文件没有定义table')
            continue

        table_name = 'st_' + st.table_name
        class_name = snake_to_pascal(table_name)
        field_name = snake_to_camel(table_name)

        config = st.get_table_config()
        exclude = config.get('exclude', [])

        key = []
        vkey = []
        akey = []
        subkey = []

        for field in st.fields:
            if field['name'] in exclude:
                continue

            field_camel = snake_to_camel(field['name'])
            kotlin_type = __kotlin_type(field['type'])

            if config.get('key') == field['name']:
                key = [field_camel, kotlin_type]
            elif config.get('vkey') == field['name']:
                vkey = [field_camel, kotlin_type]
            elif config.get('akey') == field['name']:
                akey = [field_camel, kotlin_type]
            elif config.get('subkey') == field['name']:
                subkey = [field_camel, kotlin_type]

        if key and akey:
            print('%s表同时存在key和akey' % (table_name))
            continue

        maps = []
        extentions = []
        clearings = []

        if key:
            maps.append(f"    val {field_name}Map = mutableMapOf<{key[1]}, {class_name}>()")
            extentions.append(f"fun Sheet.getAll{class_name}(): Map<{key[1]}, {class_name}> {{\n    check()\n    return {class_name}Holder.{field_name}Map\n}}")
            extentions.append(f"fun Sheet.get{class_name}({key[0]}: {key[1]}): {class_name}? {{\n    check()\n    return {class_name}Holder.{field_name}Map[{key[0]}]\n}}")
            clearings.append(f"        {field_name}Map.clear()")

        if vkey:
            maps.append(f"    val {field_name}VMap= mutableMapOf<{vkey[1]}, {class_name}>()")
            extentions.append(f"fun Sheet.get{class_name}ById({vkey[0]}: {vkey[1]}): {class_name}? {{\n    check()\n    return {class_name}Holder.{field_name}VMap[{vkey[0]}]\n}}")
            clearings.append(f"        {field_name}VMap.clear()")

        if akey:
            maps.append(f"    val {field_name}AMap = mutableMapOf<{akey[1]}, MutableList<{class_name}>>()")
            extentions.append(f"fun Sheet.get{class_name}s({akey[0]}: {akey[1]}): List<{class_name}> {{\n    check()\n    return {class_name}Holder.{field_name}AMap[{akey[0]}] ?: emptyList()\n}}")
            clearings.append(f"        {field_name}AMap.clear()")

            if subkey:
                maps.append(f"    val {field_name}PMap = mutableMapOf<Pair<{akey[1]}, {subkey[1]}>, {class_name}>()")
                extentions.append(f"fun Sheet.get{class_name}({akey[0]}: {akey[1]}, {subkey[0]}: {subkey[1]}): {class_name}? {{\n    check()\n    return {class_name}Holder.{field_name}PMap[{akey[0]} to {subkey[0]}]\n}}")
                clearings.append(f"        {field_name}PMap.clear()")

        fields = []
        for field in st.fields:
            if field['name'] in exclude:
                continue

            name = snake_to_camel(field['name'])
            typ = __kotlin_type(field['type'])
            comment = field.get('comment', '')
            if comment:
                fields.append(f"    /** {comment} */\n    val {name}: {typ}")
            else:
                fields.append(f"    val {name}: {typ}")

        mappings = ""
        if key:
            mappings += f"        {field_name}Map[value.{key[0]}] = value\n"
        if vkey:
            mappings += f"        {field_name}VMap[value.{vkey[0]}] = value\n"
        if akey:
            mappings += f"        {field_name}AMap.getOrPut(value.{akey[0]}) {{ mutableListOf() }}.add(value)\n"
            if subkey:
                mappings += f"{field_name}PMap[value.{akey[0]} to value.{subkey[0]}] = value\n"
        mappings = mappings.rstrip()

        sheet_code = sheet_template.replace('<name>', class_name)
        sheet_code = sheet_code.replace('<fields>', ',\n'.join(fields))
        sheet_code = sheet_code.replace('<maps>', '\n'.join(maps))
        sheet_code = sheet_code.replace('<extentions>', '\n\n'.join(extentions))
        sheet_code = sheet_code.replace('<mappings>',  mappings)
        sheet_code = sheet_code.replace('<clearings>', '\n'.join(clearings))

        sheet_path = '%s/server-common/src/main/kotlin/server/common/sheet/%s.kt' % (Config.code_path, class_name)
        write_file(sheet_path, sheet_code)

        sheets.append(table_name)

    load_sheets = []
    for sheet in sheets:
        load_sheets.append(f"        load({snake_to_pascal(sheet)}Holder, sheets[\"{sheet}\"])")
    sheet_loader_code = sheet_loader_template.replace('<sheets>', '\n'.join(load_sheets))
    sheet_loader_path = '%s/server-common/src/main/kotlin/server/common/sheet/Sheet.kt' % (Config.code_path)
    write_file(sheet_loader_path, sheet_loader_code)

def __kotlin_type(column_type):
    original_type = column_type

    is_array = column_type.startswith("[]")
    if is_array:
        element_type = column_type[2:]

        base_kotlin_type = type_mapping.get(element_type)
        if base_kotlin_type is None:
            raise ValueError(f"不支持的数据类型: {original_type}")

        kotlin_type = f"List<{base_kotlin_type}>"
    else:
        kotlin_type = type_mapping.get(column_type)
        if kotlin_type is None:
            raise ValueError(f"不支持的数据类型: {original_type}")

    return kotlin_type

def snake_to_pascal(snake_str):
    return ''.join(word.capitalize() for word in snake_str.split('_'))

def snake_to_camel(snake_str):
    words = snake_str.split('_')
    return words[0] + ''.join(word.capitalize() for word in words[1:])

def write_file(path, context):
    print('正在保存 %s' % (path))
    os.makedirs(os.path.dirname(path), exist_ok=True)
    f = open( path, 'w', encoding='utf-8' )
    f.write(  context.strip() )
    f.close()
