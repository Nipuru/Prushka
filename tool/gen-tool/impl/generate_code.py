import os

from .table import Table
from .config import Config
from .common import get_xls_sheet, open_file, to_json_str
from .check_excel import check_excel

type_mapping = {
    "int32": "Int",
    "int64": "Long",
    "float32": "Float",
    "float64": "Double",
    "bool": "Boolean",
    "string": "String",
}

sheet_loader_template = """
// This file is auto-generated. DO NOT EDIT.
// Generated by tool
package server.common.sheet

import com.google.gson.FieldNamingPolicy
import com.google.gson.GsonBuilder
import com.google.gson.reflect.TypeToken

object Sheet {
    private var isLoad = false
    private val gson = GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create()

    fun load(sheets: Map<String, String>) {
<sheets>
        isLoad = true
    }

    fun check() {
        if (!isLoad) throw IllegalStateException("Sheet not loaded")
    }

    private inline fun <reified T> load(holder: SheetHolder<T>, json: String?) {
        holder.clear()
        if (json == null) return
        val type = object : TypeToken<List<T>>() {}.type
        val values = gson.fromJson<List<T>>(json, type)
        for (value in values) {
            holder.put(value)
        }
    }
}

interface SheetHolder<T> {
    fun put(value: T)
    fun clear()
}
"""

sheet_template = """
// This file is auto-generated. DO NOT EDIT.
// Generated by tool
package server.common.sheet

data class <name>(
<fields>
)

<extentions>

internal object <name>Holder : SheetHolder<<name>> {
    <maps>
    override fun put(value: <name>) {
        <mappings>
    }

    override fun clear() {
        <clearings>
    }
}
"""

def generate_code():
    sheets = []
    
    for table_name in Table.tables:
        print('正在生成 %s' % (table_name))
        table = Table.tables[table_name]
        exclude = []
        if "exclude" in table:
            exclude = table["exclude"]
        class_name = snake_to_pascal(table_name)
        field_name = snake_to_camel(table_name)
        xls_file = open_file( Config.excel_path, table_name )
        sheet = get_xls_sheet( xls_file, table_name )
        if sheet == None:
            print('%s表没找到名字叫%s的标签页' % ( table_name, table_name ))
            continue
        
        comments = __getLabels( sheet.row_values( 0 ) )
        labels = __getLabels( sheet.row_values( 1 ) )
        column_types = __getLabels( sheet.row_values( 2 ) )
        key = []
        vkey = []
        akey = []
        subkey = []
        for i in range( len(labels) ):
            if labels[i] == '':
                continue
            if labels[i] in exclude:
                continue
            if column_types[i] == '':
                continue
            k = [snake_to_camel(labels[i]), __kotlin_type(column_types[i])]
            if "key" in table and table['key'] == labels[i]:
                key = k
            elif "vkey" in table and table['vkey'] == labels[i]:
                vkey = k
            elif "akey" in table and table['akey'] == labels[i]:
                akey = k
            elif "subkey" in table and table['subkey'] == labels[i]:
                subkey = k
        if key and akey:
            print('%s表同时存在key和akey' % (table_name))
            continue
        maps = []
        extentions = []
        clearings = []
        if key:
            maps.append(f"val {field_name}Map = mutableMapOf<{key[1]}, {class_name}>()")
            extentions.append(f"fun Sheet.getAll{class_name}(): Map<{key[1]}, {class_name}> {{\n    check()\n    return {class_name}Holder.{field_name}Map\n}}")
            extentions.append(f"fun Sheet.get{class_name}({key[0]}: {key[1]}): {class_name}? {{\n    check()\n    return {class_name}Holder.{field_name}Map[{key[0]}]\n}}")
            clearings.append(f"{field_name}Map.clear()")
        if vkey:
            maps.append(f"val {field_name}VMap= mutableMapOf<{vkey[1]}, {class_name}>()")
            extentions.append(f"fun Sheet.get{class_name}ById({vkey[0]}: {vkey[1]}): {class_name}? {{\n    check()\n    return {class_name}Holder.{field_name}Map[{vkey[0]}]\n}}")
            clearings.append(f"{field_name}VMap.clear()")
        if akey:
            if subkey:
                maps.append(f"val {field_name}AMap = mutableMapOf<Pair<{akey[1]}, {subkey[1]}>, {class_name}>()")
                extentions.append(f"fun Sheet.get{class_name}({akey[0]}: {akey[1]}, {subkey[0]}: {subkey[1]}): {class_name}? {{\n    check()\n    return {class_name}Holder.{field_name}AMap[{akey[0]} to {subkey[0]}]\n}}")
            else:
                maps.append(f"val {field_name}AMap = mutableMapOf<{akey[1]}, MutableList<{class_name}>>()")
                extentions.append(f"fun Sheet.get{class_name}({akey[0]}: {akey[1]}, index: Int): List<{class_name}> {{\n    check()\n    return {class_name}Holder.{field_name}AMap[{akey[0]}] ?: emptyList()\n}}")
                extentions.append(f"fun Sheet.get{class_name}s({akey[0]}: {akey[1]}): List<{class_name}> {{\n    check()\n    return {class_name}Holder.{field_name}AMap[{akey[0]}] ?: emptyList()\n}}")
            clearings.append(f"{field_name}AMap.clear()")
        fields = []
        for i in range( len(labels) ):
            if labels[i] == '':
                continue
            if labels[i] in exclude:
                continue
            if column_types[i] == '':
                continue
            name = snake_to_camel(labels[i])
            typ = __kotlin_type(column_types[i])
            comment = comments[i]
            fields.append(f"    /** {comment} */\n    val {name}: {typ}")
        mappings = ""
        if key:
            mappings += f"{field_name}Map[value.{key[0]}] = value\n"
        if vkey:
            mappings += f"{field_name}VMap[value.{vkey[0]}] = value\n"
        if akey:
            if subkey:
                mappings += f"{field_name}AMap[value.{akey[0]} to value.{subkey[0]}] = value\n"
            else:
                mappings += f"{field_name}AMap.getOrPut(value.{akey[0]}) {{ mutableListOf() }}.add(value)\n"
        mappings = mappings.rstrip()
        sheet_code = sheet_template.replace('<name>', class_name)
        sheet_code = sheet_code.replace('<fields>', ',\n'.join(fields))
        sheet_code = sheet_code.replace('<maps>', '\n'.join(maps))
        sheet_code = sheet_code.replace('<extentions>', '\n\n'.join(extentions))
        sheet_code = sheet_code.replace('<mappings>', mappings)
        sheet_code = sheet_code.replace('<clearings>', '\n'.join(clearings))
        sheet_path = '%s/server-common/src/main/kotlin/server/common/sheet/%s.kt' % (Config.code_path, class_name)
        write_file(sheet_path, sheet_code)
            
        sheets.append(table_name)
        
        
    load_sheets = []
    for sheet in sheets:
        load_sheets.append(f"        load({snake_to_pascal(sheet)}Holder, sheets[\"{sheet}\"])")
    sheet_loader_code = sheet_loader_template.replace('<sheets>', '\n'.join(load_sheets))
    sheet_loader_path = '%s/server-common/src/main/kotlin/server/common/sheet/Sheet.kt' % (Config.code_path)
    write_file(sheet_loader_path, sheet_loader_code)
    
def __kotlin_type(column_type):
    original_type = column_type
    
    is_array = column_type.startswith("[]")
    if is_array:
        element_type = column_type[2:]
        
        base_kotlin_type = type_mapping.get(element_type)
        if base_kotlin_type is None:
            raise ValueError(f"不支持的数据类型: {original_type}")
        
        kotlin_type = f"List<{base_kotlin_type}>"
    else:
        kotlin_type = type_mapping.get(column_type)
        if kotlin_type is None:
            raise ValueError(f"不支持的数据类型: {original_type}")
    
    return kotlin_type

def snake_to_pascal(snake_str):
    return ''.join(word.capitalize() for word in snake_str.split('_'))

def snake_to_camel(snake_str):
    words = snake_str.split('_')
    return words[0] + ''.join(word.capitalize() for word in words[1:])

def __getLabels( line ):
    labels = []
    for l in line:
        if l and l != '':
            labels.append( l.strip() )
        else:
            labels.append( '' )
    return labels

def write_file(path, context):
    print('正在保存 %s' % (path))
    os.makedirs(os.path.dirname(path), exist_ok=True)
    f = open( path, 'w', encoding='utf-8' )
    f.write(  context.strip() )
    f.close()